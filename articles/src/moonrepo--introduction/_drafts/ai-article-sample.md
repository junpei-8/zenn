Moonrepo（以下、moon）は、モノレポ（monorepo）環境の管理に特化したタスクランナー兼ビルドシステムです。本記事では、moonの基本概念である タスク, キャッシュ, ツールチェイン に着目し、その仕組みを分かりやすく解説します。さらに、NxやLerna、Turborepoといった他のモノレポツールとの比較を行い、moonの強みや独自性を明らかにします。最後に、大規模プロジェクトでの適用方法やチーム開発での効果的なワークフロー、ビルド高速化のポイント、そして実践的なコードサンプル（設定例やCI/CDへの組み込み方）を紹介します。

## Moonrepoの基本概念

moonはモノレポ管理において「一貫性」と「開発体験の向上」を重視したツールです。Rust製で高速に動作し、JavaScript/TypeScriptをはじめ複数言語に対応します。まず、moonの根幹をなす3つの概念 タスク, キャッシュ, ツールチェイン について見ていきましょう。

### タスクの仕組み

タスクは各プロジェクト内で実行されるコマンドの定義です。例えばビルドやテスト、リントなどがタスクにあたります。moonではタスクをプロジェクトごとの設定ファイル（moon.yml）またはグローバル設定に記述し、moon run <プロジェクト名>:<タスク名>の形式で実行します。

タスク定義は名前・コマンド・引数などで構成され、必要に応じて依存関係や入出力ファイルも指定できます。タスク間の依存関係もmoonの重要な特徴です。あるタスクが別のタスクに依存する場合、depsとしてそのタスクを指定できます。moonはプロジェクト間の依存関係とタスクの依存関係を解析して自動的に実行順序を決定します。

例えばアプリプロジェクトのビルドがライブラリプロジェクトのビルドに依存する場合、app:buildタスクにdeps: ["lib:build"]を指定すれば、実行時にまずlib:buildが完了してからapp:buildが走ります。この依存グラフは自動で構築され、可能な限りの並列実行も行われます（後述のアクションパイプラインによりスレッドプールで並列化）。そのため、大規模プロジェクトでも効率よくタスクをオーケストレーションできます。さらにmoonにはタスク定義の継承機能があります。他のツールでは各プロジェクトで同じスクリプトを何度も定義しがちですが、moonでは共通タスクを一括定義し各プロジェクトに継承させることが可能です。例えば全プロジェクト共通のlintやtestタスクを.moon/project.yml（または.moon/workspace.yml）に一度書いておけば、各プロジェクトで重複定義する必要がありません。その上で特定プロジェクトだけオーバーライドや追加引数を指定することもできます。こうした仕組みにより、モノレポ全体でタスク管理の重複を減らし、一貫した実行を担保できます。

### キャッシュの最適化

moonが高速なビルドを実現する鍵がキャッシュ機能です。moonは独自の「スマートハッシュ」方式によるビルドキャッシュを実装しており、過去のタスク実行結果を使い回すことでビルド時間を大幅に短縮できます。具体的には、タスク実行時にその入力（ソースコードや依存ファイル、環境変数など）からハッシュ値を計算し、そのハッシュに対応する出力結果を.moon/cacheに保存します。次回以降、同じタスクを実行する際に入力内容に変更がなければハッシュが一致するため、実行をスキップしてキャッシュから成果物を復元します。これがインクリメンタルビルドの仕組みです。スマートハッシュが考慮に入れる入力要素は非常に広範囲です。コマンドと引数、指定した入力ファイル群、出力先、環境変数はもちろん、プロジェクト間・タスク間の依存関係、使用する言語やパッケージのバージョンまで含めてハッシュ化します。例えばNode.jsプロジェクトのビルドタスクであれば、Nodeのバージョンやpackage.json内の依存関係、TypeScriptのコンパイラ設定などもハッシュ計算に組み込まれます。この徹底したハッシュキー管理により、「コードを1行変更しただけで別のところも再ビルドされた」といった不整合を防ぎ、精度の高いキャッシュヒットを実現しています。キャッシュにヒットした場合、moonは保存済みの成果物を展開（アーカイブとハイドレーション）して即座に利用します。前回実行時にタarringされた出力物が.moon/cache/outputs/<ハッシュ>.tar.gzにありさえすれば、解凍してプロジェクトの出力ディレクトリに展開（ハイドレート）するだけで済みます。結果、ビルド時間は大幅短縮され、不要な重複処理が避けられます。初回実行以降、変更のないタスクは「cached」と表示され一瞬で完了するため、開発者はコード変更分の処理だけに集中できます。さらにmoonはリモートキャッシュにも対応しています。デフォルトではローカルマシン上でキャッシュしますが、設定によりクラウド上にキャッシュを共有可能です。チーム開発ではCIでビルドした成果物をリモートキャッシュサービス（moon公式のMoonbaseサービスや互換のある自己ホスティングサービス）にアップロードし、他の開発者や後続のCIジョブがそれをダウンロードして利用できます。この仕組みにより、「他の人がビルド済みのものを自分の環境で再利用する」といったことがシームレスに行え、チーム全体でビルド時間の短縮とリソース節約が図れます。補足: キャッシュを最大限活かすためには、タスク定義で入出力ファイル（inputsやoutputs）を適切に指定することが推奨されています。デフォルトでは広範囲（例えば\*_/_）が入力となりますが、不要なファイルまで含めるとハッシュが頻繁に変わってしまうためです。プロジェクトごとに「ソースコードや設定ファイルのみ」を入力とし、生成物のディレクトリを出力として明示することで、キャッシュの精度と効果がより高まります。

### ツールチェインの活用

moonの他ツールにない特徴として統合されたツールチェイン管理があります。これは、プロジェクトで用いるプログラミング言語やパッケージマネージャ、ビルドツール等のバージョン管理とインストールをmoonが肩代わりする仕組みです。通常、各開発者が手元に適切なNode.jsやnpmのバージョンを用意したり、プロジェクトごとにツールをインストールしたりする必要がありますが、moonではその必要が大幅に減ります。例えば「Node.jsは16系を使う」や「pnpmは7.xを使う」といったバージョン指定を.moon/workspace.ymlに記述すれば、moon実行時に自動で対応するツールをダウンロード・セットアップしてくれます。裏側では、moonはRust製のバージョン管理ツール「Proto」を利用しており、指定された言語やパッケージマネージャをユーザー環境（ホームディレクトリ下の~/.proto）にインストールします。したがって、一度moonを導入すれば、開発者は各種ツールを個別にインストールする手間が省け、CI環境でもmoonが自動的に必要なツール群を揃えてからタスクを走らせます。すべての開発マシンやCIサーバーでツールのバージョンを強制的に一致させることで、「自分の環境では動くのにCIで失敗する」「バージョン違いによる微妙な挙動差」といった問題を根本から解消できます。例えば、以下のようにワークスペース設定でNode.jsとパッケージマネージャのバージョンを固定できます（pnpmを使用する例）。

```yml
# .moon/workspace.yml の一部

node:
  version: "16.16.0" # プロジェクト全体で使用するNode.jsのバージョン
  packageManager: "pnpm" # 使用するパッケージマネージャ（npm, yarn, pnpmのいずれか）

pnpm:
  version: "7.8.0" # pnpm自体のバージョン
  vcs:
    manager: "git" # バージョン管理システム（通常はgit）

projects:
  client: "apps/client" # プロジェクトのパスマッピング
  server: "apps/server"
```

上記の設定により、moonはNode.js 16.16.0とpnpm 7.8.0を必要に応じて取得し、以後のmoon run実行時には常にそれらを用いてタスクを実行します。さらにmoonはmoon runコマンド実行前にワークスペース全体の設定と現在の実行環境をチェックし、差異があれば自動で同期します。具体的には、Nodeやnpmのバージョンがズレていればmoon syncによって正しいバージョンを取得し、TypeScriptのプロジェクト参照も最新の状態に更新し、ローカルキャッシュも含めて必要な整合性を保ちます。これらの処理は開発者が意識しなくても自動で行われるため、チーム開発における環境のばらつきを抑え、一貫性を保つことができます。必要に応じて、このツールチェイン機能をオフにもできます。例えばCIでは事前に環境を用意してある場合など、環境変数MOON_TOOLCHAIN_FORCE_GLOBALS=trueを設定すればmoonは組み込みツールではなくシステムにインストール済みのバイナリを利用します。状況に応じて柔軟に切り替えられますが、基本的にはmoonに任せておけば安心というケースが多いでしょう。

## 他のモノレポツールとの比較

近年はモノレポ構成を支えるツールとして、Nx, Lerna, Turborepoなどが広く使われています。それぞれ特徴がありますが、moonはそれら既存ツールと比べてどのような位置付けなのでしょうか。ここでは機能面の比較を通じてmoonの強みと独自性を浮き彫りにします。

### Nxとの比較

NxはNrwl社によって開発・提供されているモノレポツールで、Angular由来の強力な機能拡張が特徴です。依存関係の解析やAffected（影響範囲）ビルド、豊富なプラグインエコシステム、コード生成スキーマ（スキャマティクス）など、モノレポ運用に必要なものが一通り揃った包括的なフレームワークと言えます。現在ではLernaを取り込む形でさらに発展しており、JavaScriptモノレポのデファクトスタンダード的存在です。そんなNxとmoonを比較すると、多くのコンセプトが重なっています。例えばローカル/リモートキャッシュや並列タスク実行、Affectedビルドへの対応、依存グラフの解析と可視化、コード生成機能など、モノレポに求められる主要機能は両者ともサポートしています。一方で、アプローチには違いがあります。NxはNode.js上で動作し（最近一部Rust実装も導入）、プラグイン機構によって様々な言語やフレームワークをサポートしています。例えばReactやAngular、NestJSなどの公式プラグインを適用すれば、それぞれに特化したスクリプトや設定が生成できます。言わば**「多機能な拡張可能プラットフォーム」**としての色彩が強いです。その分初期セットアップや学習コストはやや高めですが、大規模プロジェクトでの実績と情報も豊富です。対するmoonは、設計思想として**「言語非依存で軽量なタスクランナー」を志向しています。現状公式にサポートしている言語はNode.jsやRust、Go、Rubyなど一部ですが、基本的には任意の言語プロジェクトを扱えます。Nxが高度な機能を包括するのに対し、moonは必要な設定を記述して柔軟に使う設定駆動型**です。また前述のようにmoon自身がツールチェイン管理やCI統合機能を備えている点はNxにない独自要素です。総じて、Nxは大規模かつ多様なJSプロジェクト群に強く、moonはよりシンプルで言語横断的なアプローチを提供していると言えるでしょう。

### Turborepoとの比較

TurborepoはVercel社が提供する高速ビルドシステムで、シンプルな設定と高性能なキャッシュによるビルド最適化を売りにしています。もともとはJavaScript/TypeScript専用で、package.jsonのスクリプトをオーケストレーションする形で動作します。特徴として、設定ファイル（turbo.json）にパイプラインを定義し、各パッケージのnpmスクリプトを並列・順序制御しつつ実行するモデルです。ビルド出力のインクリメンタルキャッシュや必要最小限の再ビルドといった挙動により、大規模プロジェクトでも効率よくタスクをこなします。moonとTurborepoは一見似た目的（モノレポ内のタスク実行高速化）のツールですが、その内部構造には大きな違いがあります。端的に言えば、**Turborepoは「高度なnpmスクリプト実行管理＋キャッシュレイヤー」**であり、**moonは「独立したタスクランナー基盤」**です。TurborepoはNode.js環境下で動くため、基本的にJS/TSのプロジェクトに特化しており、設定のカスタマイズ幅も限定的です。一方moonは言語非依存かつ高い設定自由度があり、プロジェクトやタスクを独自の設定ファイルで細かく制御できます。また、moonはツールチェイン管理を内包していますが、Turborepoにはそういった機能はありません。例えばNodeのバージョン違い問題はTurborepo自体では解決できず、開発者がnvm等で揃える必要があります。さらにCIでの使い勝手にも差があります。Turborepoではturbo runコマンドで実行するタスクを明示的に指定しますが、その定義から漏れたスクリプトはCI上で自動実行されません。moonの場合、デフォルトでmoon ciコマンドを使えば全プロジェクト・全タスクをCI上で実行でき、漏れがないよう設計されています。性能面では、Turborepoも現在Rust実装への書き換えが進行中であり、将来的な高速化が予告されています。moonは初めからRustで実装されており軽量かつ高速である点も強みです。総合すると、Turborepoは「とにかく手軽に既存のnpmスクリプトを高速化したい場合」に適し、moonは「柔軟な設定と追加機能で開発体験全体を向上させたい場合」に適していると言えるでしょう。

### Lernaとの比較

Lernaはモノレポ管理ツールの草分け的存在で、複数パッケージのバージョン管理や発行（publish）を得意としてきました。Lerna自体にも簡易的なタスク実行機能（lerna runで各パッケージのnpmスクリプトを並列実行するなど）はありましたが、キャッシュや賢い依存解析は持っていませんでした。そのため大規模化すると非効率で、ビルド全体に毎回時間がかかるという欠点がありました。昨今のLernaは一時期メンテナ不在となったあとNxチームの管理下に入り、内部的にNxの機能を利用する形で生まれ変わっています。いわば「Nxの軽量版」として位置づけられており、現在のLerna v6以降は実質的にNxの一部機能（キャッシュやaffected計算）を使って動作しています。したがって、moonと直接比較すべき対象としてはやや役割が異なります。moonはLernaがカバーしていたパッケージのバージョン管理・発行機能は持っておらず（今のところ手動または他ツールに委ねる必要あり）、逆にLernaには無かった高度なキャッシュ・ハッシュ機構やツールチェイン管理を持っています。もし既存プロジェクトでLernaを使っている場合、moonへ移行することでビルド時間短縮や開発環境の統一といった恩恵を得られる可能性があります。moon公式もNxやTurborepoからの移行コマンドを提供しており、比較的スムーズに乗り換えられるよう配慮されています。

### Moonrepoの強みと独自性

以上の比較を踏まえ、moonrepoの主な強みをまとめます。統合ツールチェイン: Node.jsやその他言語の実行環境を自動管理し、一貫した開発環境を保証。他ツールには見られないmoon独自の魅力です。タスク継承による効率化: グローバルにタスクを定義し各プロジェクトで共有・上書きできるため、設定の重複を削減し管理を容易にします。高性能キャッシュとハッシュ: 微細な変更も検知するスマートハッシュと、ローカル・リモート双方のキャッシュによるビルド時間短縮。Rust製による高速処理: コアがRustで書かれており、大規模プロジェクトでも軽快に動作。特に依存グラフの解析や並列実行のオーバーヘッドが小さいです。開発者体験の向上: コマンド一つでCI上の全タスク実行（moon ci）や、変更検知による自動同期（moon sync）など、「うっかりミス」や「環境構築の手間」を減らす工夫が随所にあります。将来的な拡張性: Moonrepoはまだ新しいプロジェクトですが、将来的にリポジトリ管理全般（コードオーナーや依存関係の自動更新、シークレット管理など）への発展も計画されています。モノレポの課題を包括的に解決するプラットフォームへの成長が期待されています。

## 実務での活用例

では、moonrepoを実際のプロジェクトで活用する際、どのような利点があり、どんな使い方が効果的なのでしょうか。ここでは 大規模プロジェクト への適用と、チーム開発 におけるワークフロー改善という観点で考えてみます。

### 大規模プロジェクトへの適用方法

数十から数百のパッケージを含む大規模モノレポでは、ビルドやテストに非常に時間がかかるのが常です。moonrepoを導入することで、まずビルドの所要時間が劇的に短縮される可能性があります。例えば、あるプロジェクトでライブラリ群とアプリケーション群を含むモノレポを運用しているとします。moonのキャッシュ機能を使えば、変更のあった部分だけビルド/テストし、他は全てスキップという運用が可能になります。従来毎回1時間かかっていたCIビルドが、半分以下の時間で済むケースも珍しくありません（具体的な効果はプロジェクト規模によりますが、経験的には大規模になるほど恩恵が大きいです）。大規模プロジェクトでは依存関係の複雑さも課題ですが、moonはプロジェクト間の依存を明示的に設定し（workspace.ymlのprojectsや各moon.ymlでdependsOn指定）、それをもとにタスク実行順序を最適化します。そのため、「あるライブラリを変更したらそれに依存するすべてのサービスのテストを実行する」といった処理も自動化できます。加えて、moonにはプロジェクトやタスクをクエリ言語でフィルタリングする機能（MQL: Moon Query Language）もあり、特定の範囲のプロジェクトだけビルド・テストするといったカスタムも可能です。実務で適用する際の手順としては、まず各プロジェクトのビルド・テスト・リンター等の処理をmoonのタスクとして記述します。次に、共通する設定（例えば全てのプロジェクトでlintにESLintを使う等）はグローバルにまとめ、それ以外は個々のmoon.ymlで定義します。こうすることで、プロジェクトが増えても共通タスクは自動で適用され、一貫性が保てます。移行期間を設けることも現実的には重要でしょう。既にNxやTurborepoで運用している場合、moonに切り替える前に両者を併用し、結果を検証しながら徐々にスイッチする方法が考えられます。moon公式の移行コマンドを利用すれば、Nx/Turboの設定をある程度moonに取り込めるので、ゼロから書き起こす手間も軽減されます。

### チームでのワークフロー改善

moonrepoの導入はチーム開発の体験も向上させます。一つ大きなポイントは前述した環境の統一です。チームメンバー各自のNode.jsやnpmのバージョンがバラバラだと、「Aさんのマシンでは動くがBさんのではエラーになる」という問題が起きがちです。moonのツールチェイン管理下では、プロジェクトルートにある設定通りのバージョンが自動で使われるため、新人がリポジトリをクローンした場合でもmoon runするだけで適切な環境が構築・実行されます。結果として、セットアップに関するチーム内の問い合わせやミスが減り、生産性が上がります。また、標準化されたタスク実行もワークフローを改善します。moonを使えば「ビルドはmoon run :build、テストはmoon run :testで全プロジェクト実行」というように一貫したコマンドで済むため、ドキュメントやREADMEに長々と各パッケージの操作手順を書く必要がありません。Lintやフォーマットもmoon経由で統一できるので、開発者は自分の担当パッケージだけ見ていれば、あとの共通処理はmoonが面倒を見てくれます。moonはCI/CDパイプラインにも直結した形で機能します。特にmoon ciコマンドはCI環境向けに設計されており、CI上で実行すべき全タスクを自動で走らせることができます。これにより、「ある開発者がローカルでテストを忘れてプッシュしてしまったがCIでは検出漏れだった」といった事態を防ぎます。デフォルトでは全タスクが対象ですが、各タスクにrunInCI: falseオプションを付ければCI実行から除外することもできます。例えば開発用のデモサーバー起動タスクなど、CIでは不要なものは除く、といった柔軟性も担保されています。最後に、moon導入後はチーム内のコミュニケーションコストも下がるでしょう。moonは自動同期（moon sync）によって、「〇〇を変更したのでローカルで△△を再実行してください」といった開発者間のアナウンス自体を減らす効果があります。コードをpullしてmoon runするだけで常に最新状態が維持されるので、「うっかり必要なコマンドを実行し忘れていた」といった事態が起きにくくなります。これは心理的な安心感にもつながり、開発者は本来のコーディングに専念しやすくなります。

## 高速ビルドとキャッシュの利点

モノレポ運用で特に注目すべきは、ビルド時間の短縮とフィードバックサイクルの高速化です。moonrepoのキャッシュ機構と並列処理は、そのための強力な武器となります。この章では、ビルド高速化の具体的なメリットを整理してみます。不要なビルドの排除: 前述のとおり、moonはスマートハッシュにより変更のない部分のビルドをスキップします。例えば100プロジェクトからなるレポで1プロジェクトだけ変更があった場合、通常なら他99もビルド対象とされがちですが、moonでは99プロジェクト分が「キャッシュヒット」と判断され即完了します。その結果、増分ビルドが極めて高速になります。開発中のローカル実行でも、「ちょっと直してすぐ全体テスト」がストレスなく実行可能です。並列実行によるCPU活用: moonは内部でスレッドプールを使い、依存関係の無いタスクを可能な限り同時並行で走らせます。例えばバックエンドとフロントエンドのビルドを並列に、さらにその間にユニットテストも走る、といった具合に、マシンのコアをフル活用します。特にCIサーバーなど多コア環境では恩恵が大きく、従来直列実行していた処理を短時間で完了できるようになります。オプション--concurrencyで同時実行数を制限することも可能なので、負荷制御も柔軟です。リモートキャッシュによる全体最適: チーム開発では、ある人が時間をかけて得たビルド成果物を全員で共有できることが理想です。moonのリモートキャッシュを導入すれば、CIでビルド→キャッシュアップロードし、開発者PCからそのキャッシュをダウンロードして再利用、といったことが簡単に実現します。これにより、新人がリポジトリをクローンして初回ビルドする場合でも、過去の成果物を引き継げるため数分で環境構築が終わる、といったケースも期待できます。**「一度ビルドしたものは二度と繰り返さない」**という原則で、チーム全体の時間を節約します。安定したCIパイプライン: ビルドやテストが速くなることで、CIのサイクルタイムが短縮されます。開発者はプルリクエストの結果を素早く得られ、フィードバックループが高速化します。moonはさらに、キャッシュのおかげでCIの負荷を下げつつ、一貫性のある結果を保証します。同じ入力から常に同じ出力が得られる（リプロデューサブルビルド）ため、ある変更で不具合が出た場合でも原因を特定しやすくなります。以上のように、高速ビルドとキャッシュの利点は単に「速くなる」だけでなく、開発サイクルそのものの質を向上させます。開発者体験の向上、より頻繁なデプロイの実現、CIリソースコスト削減など副次的なメリットも多々あります。特にモノレポ規模が大きいほど、moonによる高速化のインパクトは大きく現れるでしょう。

## 実践的なコードサンプル

最後に、moonrepoを使った設定や運用の具体例をコードサンプルで紹介します。シンプルなモノレポを想定し、タスク定義の例, キャッシュを活用したビルド設定, CI/CDへの組み込み方法を順に示します。

### タスク定義とプロジェクト構成の例

まず、モノレポ内に**共通ライブラリ（lib）とアプリケーション（app）**の2つのプロジェクトがあるケースを考えます。libはビルド後にdist/ディレクトリに成果物を出力し、appはlibに依存しているものとします。moonの設定ファイルを以下のように用意します。

```yml
# .moon/workspace.yml - ワークスペース共通設定

projects:
  lib: "packages/lib" # プロジェクトIDとパスの対応付け
  app: "packages/app"

node:
  version: "18.14.0" # Node.jsのバージョン指定（例）
  packageManager: "pnpm" # パッケージマネージャ指定

pnpm:
  version: "8.6.0" # pnpmのバージョン指定
```

```yml
# packages/lib/moon.yml - ライブラリプロジェクトの設定

language: javascript
type: library
project:
  name: "lib"
  description: "共通ライブラリ"

tasks:
  build:
    command: "tsc" # TypeScriptコンパイルコマンド
    args: ["-p", "tsconfig.json"]
    inputs: ["src/**/*", "tsconfig.json", "package.json"] # ハッシュ計算に含める入力
    outputs: ["dist"] # キャッシュ対象の出力ディレクトリ
```

```yml
# packages/app/moon.yml - アプリケーションプロジェクトの設定

language: javascript
type: application
project:
  name: "app"
  description: "アプリケーション本体"
  dependsOn: ["lib"] # プロジェクトレベルの依存関係（libプロジェクトに依存）

tasks:
  build:
    command: "webpack" # アプリケーションのビルドコマンド
    deps: ["lib:build"] # このタスクはlibプロジェクトのbuildタスクに依存
    inputs: ["src/**/*", "webpack.config.js", "package.json"]
    outputs: ["dist"]

  start:
    command: "node"
    args: ["dist/index.js"]
    deps: ["~:build"] # 同じプロジェクト内のbuildタスク完了後に実行
```

上記の設定では、libのbuildタスクがまずTypeScriptのコンパイルを行い、distに成果物を出力します。一方appのbuildタスクはdepsでlib:buildを指定しているため、自身のビルドを行う前にlibのビルドが実行されます。両プロジェクトともoutputsにdistを指定しているので、ビルド結果はキャッシュに保存されます。したがって、一度moon run app:buildを実行すれば、次回以降libやappのソースに変更がない限り、moon run app:buildは二つのビルドタスクをスキップ（キャッシュヒット）し、短時間で完了します。変更が発生した場合でも、変更のあった方だけ再ビルドされるため非常に効率的です。また、appのstartタスクはビルド後のアプリ実行を行います。このタスクは同じプロジェクト内のbuildに依存（~:build）しているため、moon run app:startとすればビルド→実行が続けて行われます。moonではこのように柔軟なタスク定義が可能で、npmスクリプトを使っていた場合と比べても直感的に依存関係を管理できます。

### キャッシュと高速ビルドの活用

上記の設定例のようにinputsとoutputsを明確に定めることで、キャッシュによるビルド高速化が最大限に活きてきます。例えばlibに変更がない状態でappを何度ビルドしても、lib側は常にキャッシュヒットしてスキップされます。さらに、仮にlibを変更してビルドし直しても、その新しい成果物ハッシュがCIのリモートキャッシュに保存されれば、他の開発者の環境や後続のCIジョブでappをビルドする際にlibのビルドは省略されます。ヒント: 開発時にはmoon run -c <タスク>オプション（--continue）を使うことで、途中のタスクが失敗しても可能な限り他のタスクを続行する、といった実行もできます。キャッシュと組み合わせれば、一部のテストが落ちてもビルド結果は残しておき後で再利用、というワークフローも取れます。また、ローカル開発中にキャッシュを無視して強制的に再実行したい場合は--updateCacheオプション（キャッシュを更新）や--skipCacheオプション（キャッシュを完全無視）も提供されています。状況に応じて使い分けることで、キャッシュによる利便性と手動実行の柔軟性を両立できます。

### CI/CDへの組み込み

moonrepoをCI/CDに組み込むのは比較的簡単です。基本となるのは**moon ciコマンドの活用**です。このコマンドはCI上で必要なすべてのタスクを実行するために設計されており、並列実行や結果のレポートにも対応しています。例えばGitHub Actionsでmoonを用いる場合、ワークフローのステップに以下のようなジョブを追加できます。

```yml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18.14.0
      - run: npm install -D moonrepo
      - run: npx moon sync
      - run: npx moon ci
```

上記では、まずNodeをセットアップしmoonrepoパッケージをインストールしてからmoon ciを実行しています。moon ciはデフォルトで変更があったプロジェクトのみを対象に全タスクリストを走らせます。大規模な場合は環境によっては一度に全て動かすのが負荷になるため、matrix機能や--job/--jobTotalオプションを使った分割実行も可能です。moonはCIサービスごとの並列実行環境変数（例えばCircleCIのCIRCLE_NODE_INDEXなど）にも対応しており、ドキュメントで具体的な設定例が紹介されています。キャッシュの永続化については、先述のリモートキャッシュサービスを使う方法と、CIサービスのキャッシュ機能を使う方法があります。moon公式のMoonbase（現在ベータ）や互換のクラウドサービス（例: Depot社のサービス）を利用すれば、ほぼ自動でキャッシュが共有されます。もし導入しない場合でも、GitHub Actionsのactions/cacheなどを用いて.moon/cache/outputsディレクトリを保存・復元することで簡易的に成果物を共有可能です（ただしhashesディレクトリは各ジョブごとに内容が変わるため注意）。リモートキャッシュを使わない場合は、キャッシュキーにGitのコミットハッシュなどを含め、適宜無効化しないと古い成果物を参照してしまう点に注意が必要です。最後に、moonにはCI結果をGitHubのプルリクエストに投稿するAction（moonrepo/run-report-action）も用意されています。これを使えば、moon ciの実行結果（成功したタスク数やキャッシュヒット率、失敗内容など）を見やすくレポートすることも可能です。CIへの組み込みにおいてもmoonは開発者体験を向上させる工夫が凝らされています。

## おわりに

moonrepo（moon）は、新進気鋭のモノレポ管理ツールとして登場し、そのスマートなキャッシュ機構や統合ツールチェインなどユニークな機能で注目を集めています。タスクの定義から実行、キャッシュによる高速化、開発環境の統一とCI/CDまで、モノレポ運用における様々な課題に対し実践的なソリューションを提供してくれます。本記事ではmoonの基本概念と他ツール比較、そして実務での活用ポイントを解説しました。平易な言葉と具体例を交えて紹介しましたので、moonrepoの全体像と魅力を感じ取っていただけたでしょうか。既存のNxやTurborepo環境からの移行も視野に、モノレポのビルド時間短縮や開発効率向上を検討している方は、一度moonrepoを試してみることをお勧めします。公式ドキュメントも充実しており、コミュニティによる情報発信も増えてきています。モノレポの世界はプロジェクトの成長とともに進化しています。moonrepoはその新たな選択肢として、今後さらに機能拡充や事例の蓄積が進むでしょう。高速で一貫性のあるモノレポ運用を目指す開発チームにとって、moonrepoは強力な武器となり得ます。ぜひ本記事の内容を参考に、moonrepoの導入や活用を検討してみてください。あなたのプロジェクトのビルドが月のように滑らかに進むことを願っています。
